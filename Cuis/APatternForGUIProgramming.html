<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><!-- Provided by MyFreeTemplates.com -->


<title>Juan's place</title><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<meta content="Keywords here" name="keywords">
<meta content="Stuff from Juan Vuletich" name="description">
<meta content="MyFreeTemplates.com" name="Author">
<meta content="index, follow" name="robots"><!-- (Robot commands: All, None, Index, No Index, Follow, No Follow) -->

<meta content="30 days" name="revisit-after">
<meta content="global" name="distribution">
<meta content="general" name="rating">
<meta content="english" name="Content-Language">
<link type="text/css" rel="stylesheet" href="images/myfreetemplates.css"></head>
<body leftmargin="0" topmargin="0" onload="MM_preloadImages('images/btn_home_dn.jpg','images/btn_about_dn.jpg','images/btn_contact_dn.jpg','images/btn_products_dn.jpg','images/btn_support_dn.jpg','images/btn_news_dn.jpg')" marginheight="0" marginwidth="0">
<table border="0" cellpadding="0" cellspacing="0" height="100%" width="100%">
<tbody>
<tr>
<td height="87">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<td rowspan="2" width="342"><img src="images/toplogo.jpg" height="87" width="342"></td>
<td rowspan="2" width="34"><img src="images/topmidspace.jpg" height="87" width="34"></td>
<td background="images/topbg.jpg"><img src="images/topbg.jpg" height="54" width="1"></td>
</tr>
<tr>
<td background="images/topnavbg.jpg"><a href="../index.html"><img style="border: 0px solid ; width: 55px; height: 33px;" alt="" src="images/btn_home.png" name="btn_home" id="btn_home" onmouseover="MM_swapImage('btn_home','','images/btn_home_dn.jpg',1)" onmouseout="MM_swapImgRestore()"></a><img src="images/navspacer.jpg" height="33" width="1"><a href="../aboutMe.html"><img style="border: 0px solid ; width: 58px; height: 33px;" alt="" src="images/btn_about.png" name="btn_about" id="btn_about" onmouseover="MM_swapImage('btn_about','','images/btn_about_dn.jpg',1)" onmouseout="MM_swapImgRestore()"></a><img src="images/navspacer.jpg" height="33" width="1"><a href="../features.html"><img style="border: 0px solid ; width: 67px; height: 33px;" alt="" src="images/btn_features.png" name="btn_contact" id="btn_contact" onmouseover="MM_swapImage('btn_contact','','images/btn_contact_dn.jpg',1)" onmouseout="MM_swapImgRestore()"></a><img src="images/navspacer.jpg" height="33" width="1"><a href="../projects.html"><img style="border: 0px solid ; width: 79px; height: 33px;" alt="" src="images/btn_projects.png" name="btn_products" id="btn_products" onmouseover="MM_swapImage('btn_products','','images/btn_products_dn.jpg',1)" onmouseout="MM_swapImgRestore()"></a><img src="images/navspacer.jpg" height="33" width="1"><a href="../research.html"><img style="border: 0px solid ; width: 72px; height: 33px;" alt="" src="images/btn_research.png" name="btn_support" id="btn_support" onmouseover="MM_swapImage('btn_support','','images/btn_support_dn.jpg',1)" onmouseout="MM_swapImgRestore()"></a><img src="images/navspacer.jpg" height="33" width="1"><img style="width: 50px; height: 33px;" alt="" src="images/btn_news.png" name="btn_news" id="btn_news" onmouseover="MM_swapImage('btn_news','','images/btn_news_dn.jpg',1)" onmouseout="MM_swapImgRestore()"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td valign="top">
<table background="images/topnavbg.jpg" border="0" cellpadding="0" cellspacing="0" height="100%" width="100%">
<tbody>
<tr>
<td colspan="2" background="images/basebg2.jpg" height="9"><img src="images/basebg2.jpg" height="9" width="1"></td>
</tr>
<tr>
<td rowspan="2" valign="top" width="150">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<td valign="top"><img style="width: 170px; height: 238px;" alt="" src="images/mainpic1.jpg"></td>
</tr>
<tr>
<td bgcolor="#ffffff" height="1"><img src="images/spacer.gif" height="1" width="1"></td>
</tr>
<tr>
<td><br>
<br>
<img src="images/spacer.gif" height="1" width="1"> &nbsp;<a href="http://www.jvuletich.org/Cuis/CategoriesAndChangeSets.txt"><span style="color: rgb(102, 51, 255);"></span></a><br>
<br>
</td>
</tr>
</tbody>
</table>
</td>
<td bgcolor="#ffffff" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<td colspan="3" background="images/navbasebg.jpg" height="29"><img src="images/navbasebg.jpg" height="29" width="1"></td>
</tr>
<tr>
<td width="40">&nbsp;</td>
<td>
<h2 style="text-align: right;">September 2010</h2>
<h1 style="text-align: center;"><br>
</h1>
<h1 style="text-align: center;"><big><big>A pattern for GUI programming</big></big></h1>
<p><br>This
document summarizes the way LightWidgets are intended to be used. The
style for GUI programming is based on PluggableViews in MVC and
PluggableMorphs in Morphic. The main idea is to have a reusable set of
standard widgets that can be customized when used by application developers. There is a strict
separation between views and models. Models don't know about views,
they are never aware of them. Views know about their model and update
it directly. Therefore, there's no need for views to trigger events, and they don't do it.<br><br>This description is not only conceptual, or theoretic. The rules described here are to actually be followed.<br><br>GUIs
are built by composing widgets. The main view is a subclass of
CompositeLW. There is a complete separation between Model and Views.<br><br></p><h3>Rule 1. Models should never include GUI code<br></h3><p>They
must be completely unaware of possible Views that operate on them.
There could be at any time any number of different views active on the
same model. They could belong to different technologies or frameworks.
They could even be remote and run on a different computer. There could
be no view at all. For example, the model could be driven by scripts or
reside on a server and receive external commands. However, this
document will only describe local LightWidgets GUIs.</p><h3>Rule 2. Views should never include any model code<br></h3><p>The
view could be replaced anytime with a different one. Besides, a model
should be able to run without any GUI at all. So any logic that belongs
in the model but is included in the GUI will eventually be missing. The
Views should query and modify Models only through public protocols,
called 'Inquiries' and 'User Commands'.</p><h3>Rule 3. Views know about the model they operate on<br></h3><p>Views
have an instance variable to hold their model. They can query Model
Inquiries when needed. They can also issue User Commands when
appropriate. Models are usually subclasses of ActiveModel. Let's
consider a small example. We are building a GUI to operate on some
Person objects. We'll consider an EntryField for the birthday of
aPerson. LightWidget includes the following instance variables:<br></p><ul><li><p>target : Holds the Model. For our example, the model of the EntryField
would be the Person. We call it target, because sometimes it might be a
view </p></li><li><p>aspect : It is a symbol, the getter for the aspect we are showing. In this case it would be #birthday.</p></li><li><p>aspectAdaptor : It is a symbol, a message that is sent to the aspect to
adapt it to the widget. As the widget is an EntryField and the aspect
is a Date, the aspectAdaptor could be #asString. This relies the Model
from the need to provide an appropriate getter for each kind of
possible widget for each attribute.</p></li><li><p>action : The action is the setter used to update the aspect on the model. In this example, it is #birthday:.</p></li><li><p>actionAdaptor : It is used to adapt the value the user entered in the
widget for use as an argument of action. In this example it could be
#asDate.</p></li></ul><p>It is usually a good idea to initialize model aspects
with reasonable defaults, and avoid nil values. This saves a lot of
#ifNil: messages in the gui.</p><h3>Rule 4. View Structure<br></h3><p>A Model could have a tree-like structure. It could be composed of other Models. This is not mandatory.</p><p>Views
always have a tree-like structure. The leaves are simple widgets. The
internal nodes are CompositeLWs. They can all share the same model, or
they could could use different parts of the bigger model. Anyway, they
are always customized with the aspec and action.</p><h3>Rule 5. GUI construction<br></h3><p>The
construction of the Views tree and the customization of each widget is
done by a main view. The main view also specifies how the Views are
notified of model changes for updating.</p><h3>Rule 6. Instance variables in views</h3><p>Additional
instance variables in GUIs are of two kinds: They can be uses to hold
sub-views, or to hold 'Model Extensions'. Possible uses of&nbsp; Model
Extensions include:</p><ul><li><p>Holding information that can be obtained
from the aspect, but that could be expensive and it makes sense to
cache. For example, our EntryField could hold an array if indices of
word starts and ends or some other internal detail.</p></li><li><p>Holding
state that is meaningful for the widget, but that it doesn't make any
sense to keep in the model. An example could be the cursor position in
our EntryField. Others could be visual options, such as a graph type or
graph style for an application generated graph.</p></li><li><p>Not-yet-commited information, entered by the user, but awaiting for OK / Cancel.</p></li></ul><p>In general, Model Extensions usually are re-fetched from the model, or re-set to default values when the model changes.</p><h3>Rule 7. View updating because of model changes</h3><p>Any
widget (in fact, any Morph) can redraw itself when needed, with the
#changed method. But when there is a change in the Model, the views
must be updated appropriately. All the Model Extensions must be
updated, and all sub-views must be updated too.<br><br>When there is a
change in the Model, the Views must receive the #modelChanged message.
A main view (i.e. a view that is not subview of another view with the
same Model) must send itself #beMainViewOn: on construction. This does
'target when: #selfChanged send: #safeModelChanged to: self'. The Model
must trigger event #selfChanged when appropriate. #safeModelChanged
will eventually update all subviews recursively. So only a main view
should receive the #selfChanged event. Models are usually subclasses of
ActiveModel, to use the more advanced events implementation there.<br><br>This is the implementation of #beMainViewOn: . This message should be used to set the model of a main view.</p><span style="color: rgb(51, 0, 153);">beMainViewOn: aModel</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;"We are a main view on aModel.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;This means:</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- aModel is a real model, i.e. not a widget.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- no aspect or aspectAdaptor. We show the whole thing.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- no action or actionAdaptor. There is no main action.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- we must update ourselves on #selfChanged event"</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;self target: aModel aspect: nil aspectAdaptor: nil modelChangeEvent: #selfChanged</span><p>The
main update method is #modelChanged. #safeModelChanged is only to
guarantee that the update is done in the User Interface process, in the
inter-cycle paus. The implementation of #modelChanged at LightWidget is:</p><span style="color: rgb(51, 0, 153);">modelChanged</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;"The model changed is some way.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;This is usually the pace to call #targetAspect to fetch the current value of the aspect from the</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;model, and to store it in some Model Extension.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;We must update all Model Extension instance variables with values from the model (i.e. target)</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;or with appropriate defaults.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;We must update ourselves and all subviews to reflect the model's new state"</span><br style="color: rgb(51, 0, 153);"><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;self updateView</span><p>#modelChanged must be reimplemented in classes with model extensions. Check the implementors to see how they work.</p><p>After updating the model and model extensions, #updateView is called. This is the implementation at LightWidget:</p><span style="color: rgb(51, 0, 153);">updateView</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;"The model or some Model Extension changed is some way.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;We must update ourselves to reflect the new state.</span><br style="color: rgb(51, 0, 153);"><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;This is the place to update secondary Model Extensions or any other state that must be updated</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;after model or Model Extension change.</span><br style="color: rgb(51, 0, 153);"><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;This method is usually reimplemented in CompositeLWs, to update subviews.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;The subviews should be sent one of the following messages:</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;target:</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;target:aspect:</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;target:aspect:aspectAdaptor:</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;target:aspect:aspectAdaptor:aspectChangeEvent:</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;to update their model and do a full update, as triggered by #modelChanged"</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;self changed</span><p>Warning:
Never implement other methods like #updateViews. If for performance
reasons the updating of subviews must be splitted in parts, then the
views and subviews must be restructured accordingly. Then, each part
can be updated as a whole with the #updateView method. Each part can be
updated by more specific model change events, or alternatively, they
might be set different submodels. Both options are described below.<br><br>The update of widgets should never trigger the action of the widget.</p><h3>Rule 8. View updating because of Model Extension changes</h3><p>If
the target of a widget is another widget, the action is a User Command
on the target widget. These methods should not update the model,
because if this was the case, the target should be the model and not
the widget. Therefore, User Command methods in widgets can only update
Model Extensions or trigger view actions, such as opening new views,
etc. If they update Model Extensions they should call #updateView, so
the change is shown in the widget and its subviews.</p><span style="color: rgb(51, 0, 153);">sampleUserCommand: data</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;modelExtension1 := data.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;self updateView</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;"Must call updateView because the model didn't change, and it will not trigger any change event"</span><h3>Rule 9. Subview updating because of submodel changes<br></h3><p>If
the model has a tree-like structure, its view will send #beMainViewOn:
aSubModel to some subviews with a part of the model as the argument. In
this case, subviews will need to be notified of the events of their own
models. This is because the submodel might trigger the #selfChanged
event, and only the views on it should be updated. Views on the bigger
model don't need to be updated. This is good for performance when
having complex models and views.</p><h3>Rule 10. Subview updating because of model minor changes<br></h3><p>There
is another reason for subviews receiving event notifications. A model
could trigger a more specific #someAspectChanged event and NOT the main
#selfChanged event. This could be done to avoid superfluous and
extensive views updating. In this case, some specific view on the view
tree should receive the #updateView message, and only the widgets that
are part of it will be updated.</p><p>So, the owning view should send #target:aspect:aspectAdaptor:modelChangeEvent: to these subviews. The implementation is:</p><span style="color: rgb(51, 0, 153);">target: aModel aspect: aSymbol aspectAdaptor: anotherSymbol modelChangeEvent: eventSymbol</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;"Widgets are notified of model changes by being sent #modelChanged.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;This happens when:</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- The widget is given a new model (or target widget), aspect or aspect adaptor</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;- An owner view is updated</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;In addition, main views are updated from model events. See #beMainViewOn:</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;But other widgets might update on more specific events from the model. This is useful to </span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;update only a small subview, and not the whole main view.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;This message is sent to such widgets, to set this specific event.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;Warning:</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;When models change, they should trigger just one event.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;It might be #selfChanged (the most general one) or a more specific one.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;But it should not trigger more than one event for each change."</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;self target: aModel aspect: aSymbol aspectAdaptor: anotherSymbol.</span><br style="color: rgb(51, 0, 153);"><span style="color: rgb(51, 0, 153);">&nbsp;&nbsp; &nbsp;target when: eventSymbol send: #safeModelChanged to: self</span><p>Warning:
When a model triggers more specific change events we must make sure
some widget will be notified of them. Otherwise, those changes could
not be shown to the user.</p><h3>Rule 11. Accessing views<br></h3><p>Nobody
should ever query a widget for value or status. A widget should not
even query itself for current value or such. The last value or state
entered by the user should be stored in the model and/or Model
Extensions. When needed, it should be retrieved from there. The only
legitimate accesses to subviews are in #initialize and in #updateView.
Check implementors of #updateView.</p><h3>Rule 12. Model updating<br></h3><p>Views
DO NOT trigger events. This is not "Event Oriented Programming". This
is Object Oriented Programming. The model is updated using the action
and the optative actionAdaptor. Methods that react to user activity
should update the model by just using the action, a simple message.
They are not allowed to ask the model for some other object to work on
it. They are not allowed to send other messages to the model. They are
allowed to modify Model Extensions. If they do, they should also
send 'self modelChanged' because an action might not modify the model
and therefore there could not be a model change event. See
ButtonLW&gt;&gt;mouseUp: for an example of this.<br><br>If you ever
feel the need to update the object answered by the aspec, instead of
sending a new value to the model (ivar target), it is because that
aspect should be the real model.</p><h3>Rule 13. GUI building<br></h3><p>Main
views know about their subviews. Therefore it's them, in theire
#initialize method, who build the subviews and customizes them. Views
are created before assigning target or model to the main view.
Afterwards, the model or target is set, and #modelChanged is called. As
seen before, this will set the model or target of all subviews
recursively.</p><h3>Misc. notes<br></h3><p>I believe nobody should do
#modelChanged, but only #safeModelChanged. Think a bit about this.
Maybe if we're certain we're in the UI process, #modelChanged is ok...</p><p>If
a visual detail like #fontColor: in a LabelLW&nbsp; is updated, after
updating the ivar, the widget should do 'self changed'. Check the code
to see that it is actually done!</p><p>
Thanks for reading.</p>
<br>
</td>
<td width="25">&nbsp;</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td bgcolor="#ffffff">&nbsp;</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td background="images/basebg1.jpg" height="24"><img src="images/basebg1.jpg" height="24" width="1"></td>
</tr>
<tr>
<td background="images/basebg2.jpg" height="44" valign="top">
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<td class="baseline" height="26">&nbsp;&nbsp;©
2006-2010 Juan M. Vuletich</td>
<td class="baseline" align="right"><span style="text-decoration: underline;"></span></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</body></html>